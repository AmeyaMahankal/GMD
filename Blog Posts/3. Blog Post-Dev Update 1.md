# Blog Post-Dev Update 1
# Blog Post-Dev Update 1
> [!NOTE]
> V.1 Created on <<<>>>
## Introduction
The objective of this milestone was to successfully establish the core elements of 
our game, namely allowing the player to sneak past enemies or engage them in combat. 
In the following sections, we will be showcasing and discussing how we implemented our
systems as well as the user interface,player movement, and animations.

### MenuStuff/Animator  

### Combat  
The main objective of this system was to give the player the ability to perform melee
attacks. This was done by adding collisions to the objects, and some animations for
the combat. A dummy enemy was added for testing collisions.

### Stealth 

The main objective of this system was to have enemies that could detect the player 
character as well as allow the player to sneak behind and stealthily attack an enemy.

#### Enemy Field of View

![StealthFOVGizmos.gif](PicturesAndGifs%2FStealthFOVGizmos.gif)

Here we implemented a system where the enemy object could detect the player if 
within a certain range and angle ahead of the object.

```
private void OnDrawGizmos()
{
    Gizmos.color = Color.yellow;
    Gizmos.DrawWireSphere(transform.position, maxRadius);

    Vector3 fovLine1 = Quaternion.AngleAxis(maxAngle, transform.up) * transform.forward * maxRadius;
    Vector3 fovLine2 = Quaternion.AngleAxis(-maxAngle, transform.up) * transform.forward * maxRadius;

    Gizmos.color = Color.blue;
    Gizmos.DrawRay(transform.position, fovLine1);
    Gizmos.DrawRay(transform.position, fovLine2);

    if (!isInFOV)
    {
        Gizmos.color = Color.red;
    }
    else
    {
        Gizmos.color = Color.green;
    }
    Gizmos.DrawRay(transform.position, (player.position-transform.position).normalized*maxRadius);

    Gizmos.color = Color.black;
    Gizmos.DrawRay(transform.position, transform.forward * maxRadius);
}
```
We also added some gizmos in order to see the correct parameters for range and
angle for the enemy view in order to tweak detection so it is fair for the player.
For now the enemy does not start moving and attacking the player which will be
added in the next milestone and currently changes the color of the ray to the
player to show detection.

```
public static bool inFOV(Transform checkingObject,Transform target,float maxAngle,float maxRadius)
{
    Collider[] overlaps = new Collider[10];
    int count = Physics.OverlapSphereNonAlloc(checkingObject.position, maxRadius, overlaps);

    for(int i = 0; i < count + 1; i++)
    {
        if (overlaps[i] != null)
        {
            if (overlaps[i].transform == target)
            {
                Vector3 directionBetween = (target.position - checkingObject.position).normalized;
                directionBetween.y *= 0;

                float angle = Vector3.Angle(checkingObject.forward, directionBetween);

                if(angle <= maxAngle)
                {
                    Ray ray = new Ray(checkingObject.position, target.position - checkingObject.position);
                    RaycastHit hit;

                    if(Physics.Raycast(ray,out hit, maxRadius)){
                        if (hit.transform == target)
                        {
                            return true;
                        }
                    }
                }
            }
        }
    }

    return false;
}
```
#### Usage:
```
    public Transform player;
    public float maxAngle;
    public float maxRadius;

    private bool isInFOV=false;

void Update()
{
    isInFOV = inFOV(transform, player, maxAngle, maxRadius);
}
```
Above is the script where we detect if the player is in the enemy's FOV by:
<ol>
<li>Finding objects within the maxRadius of the checkingObject(Enemy) and storing it the array overlaps.

<li>We then go through this list checking if null and if the object is the target(Player),

<li>and checking if the angle to the player and the enemy is less than the maxAngle.

<li>A raycast is then sent to see of there is actual line of sight and no objects in between,

<li>Finally returns true if all previous conditions are fulfilled
</ol>


#### Stealth Attack

![StealthAttackGizmos.gif](PicturesAndGifs%2FStealthAttackGizmos.gif)

Here we implemented a system allowing the player to stealthily attack an enemy if behind and with a certain angle and distance.

```
    public float killDistance = 2f;   
    public float killAngle = 45f;     

    void OnDrawGizmos()
    {
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, killDistance); 

         Vector3 backward = transform.position - transform.forward * killDistance;

        Quaternion leftRotation = Quaternion.Euler(0, killAngle+90, 0);   
        Quaternion rightRotation = Quaternion.Euler(0, -killAngle-90, 0); 

        Vector3 leftDirection = leftRotation * -transform.forward * killDistance;
        Vector3 rightDirection = rightRotation * -transform.forward * killDistance;
                
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(transform.position, transform.position + leftDirection);
        Gizmos.DrawLine(transform.position, transform.position + rightDirection);
    }
```

Once again, we used gizmos in order to visualize the area in which the player could attack the enemy to assist in development.

```
void TryStealthKill()
    {
        GameObject[] enemies = GameObject.FindGameObjectsWithTag("Enemy");
        GameObject closestEnemy = null;
        float closestDistance = Mathf.Infinity;

        // Find the closest enemy within range
        foreach (GameObject enemy in enemies)
        {
            float distance = Vector3.Distance(transform.position, enemy.transform.position);
            if (distance < closestDistance && distance <= killDistance)
            {
                closestEnemy = enemy;
                closestDistance = distance;
            }
        }

        if (closestEnemy == null) return; // No enemy in range

        // Check if the player is behind the enemy
        Vector3 toPlayer = (transform.position - closestEnemy.transform.position).normalized;
        float dotProduct = Vector3.Dot(closestEnemy.transform.forward, toPlayer);
        float requiredDot = Mathf.Cos(killAngle * Mathf.Deg2Rad);

        if (dotProduct > requiredDot)  // Ensures the player is behind enemy
        {
            PerformStealthKill(closestEnemy);
        }
    }

    void PerformStealthKill(GameObject enemy)
    {
        Debug.Log("Stealth Kill Executed!");
        Animator enemyAnimator = enemy.GetComponentInChildren<Animator>();
        if (enemyAnimator)
        {
            enemyAnimator.SetTrigger("Die");

        }

        Destroy(enemy, 4f);

    }
```
![AnimatorWindow](AnimatorWindow.png)
Above we have the script showcasing how the player can stealthily attack an enemy with some angle and distance restrictions.

Here when the player attempts a stealth kill,

1. Initialize a list of enemies with the tag `"Enemy"`.
2. Determine the closest enemy from the list and calculate the distance to that enemy and check if it is within range.
3. Check if the player is within the angle behind the closest enemy.
4. If the condition is met, perform a stealth attack:
   - Activate the trigger for the enemy’s death animation.
   - Destroy the enemy object after a delay of 5 seconds.


## Conclusion

 Ultimately we have covered a lot of ground in implementing most of our essential systems for the game. There’s still work to be done with polishing our animations and scripts, as well as integrating and combining our work.
 
We will proceed to expand on our systems and prepare to work on our second milestone.
