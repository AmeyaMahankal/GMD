# Blog Post-Dev Update 2
> [!NOTE]
> V.1 Created on <<<>>>

## Introduction
The objective of this milestone was to further enhance our system by improving our enemy AI to be able to follow a route where the enemy could be interuppted by spotting the player and chase after the enemy to attack as well as  lose track and go back original route. 

### Enemy AI
####Combat

### Stealth Improvements

We have implemented our routing with the help of some scripts in order to make createive levels where the player will need to time their movements to avoid enemies if they want to sneak by.

![alt text](EnemyPathing.gif)

This was done with two scripts WayPointPath and EnemyPathing where,

#### WaypointPath.cs

This file is responsible for holding the transforms of all positions the enemy needs to move to. 
```
public Transform[] waypoints;
```

The pathing also has the oppurtunity for an alternate route where the enemy could reverse it direction when completing one round.For now the path is by default only loop.

```
public enum PathType
    {
        Loop,
        ReverseWhenComplete
    }

    public PathType pathType = PathType.Loop;
```

Next we have a simple method that would be used in order to get the current way point's transform will be used by the EnemyPathing.cs script.Nothing major, just returning the next waypoint's position.

```
public Vector3 GetCurrentWayPoint()
{
    return waypoints[index].position;
}
```

Next we have the method for getting the next waypoint, where we check if there is no waypoints, so it is a stationary enemy. 

The next index is calculated using a private method  where we get append the direction which for now proceeding with a simple Loop just does a modulus so we do not go out of bounds.

For the case of Reversing when complete, we check if the index is out of bounds and reverses direction and index.

```
    public Vector3 GetNextWaypoint()
    {
        if (waypoints.Length == 0)
        {
            return transform.position;
        }

        index = GetNetWaypointIndex();
        Vector3 nextWaypoint = waypoints[index].position;

        return nextWaypoint;
    }

    private int GetNetWaypointIndex()
    {
        index += direction;

        if (pathType == PathType.Loop)
        {
            index %= waypoints.Length;
        }
        else if (pathType == PathType.ReverseWhenComplete)
        {
            if (index >= waypoints.Length || index < 0)
            {
                direction *= -1;
                index += direction * 2;
            }
        }

        return index;
    }
```

We also had some gizmos to show the waypoints for debugging as we disabled the waypoints mesh rendererrs.

```
private void OnDrawGizmos()
    {
        if (waypoints == null || waypoints.Length == 0)
        {
            return;
        }

        for (int i = 0; i < waypoints.Length - 1; i++)
        {
            if (waypoints[i] != null && waypoints[i + 1] != null)
            {
                Gizmos.DrawLine(waypoints[i].position, waypoints[i + 1].position);
            }
        }

        if (pathType == PathType.Loop || pathType == PathType.ReverseWhenComplete)
        {
            if (waypoints[0] != null && waypoints[waypoints.Length - 1] != null)
            {
                Gizmos.DrawLine(waypoints[waypoints.Length - 1].position, waypoints[0].position);
            }
        }
    }
```

#### EnemyPathing.cs

This script works with the previously discussed WaypointPath.cs and makes use of its public methods in order to control the NavMesh component. 

```
    [SerializeField] float waitTimeOnWayPoint = 1f;
    [SerializeField] WaypointPath path;

    private NavMeshAgent agent;
    Animator animator;
```

Here we grab references to the components reguired for the NavMeshAgent as well as the animator which is present as component in the child of the scripts object.

```
private void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        animator = GetComponentInChildren<Animator>();
    }
```

Now in the update function we add the  logic where the agent waits for a while before finally setting the next destination that the navmesh agent needs to follow.

While this is occuring we update the animator which uses a blend tree from a idle animation and a zombie walk animation by setting a float "Speed" of the enemy.

```
float normalizedSpeed = Mathf.InverseLerp(0, agent.speed, agent.velocity.magnitude);
if (animator != null)
{
    animator.SetFloat("Speed", normalizedSpeed);
}
```

![alt text](image-3.png)

Finally we have a public method to disable the navmesh agent as there was a funny phenomenon without this where the enemy's corpse would keep patrolling even after being in the "Die" state of animation.

```
    public void DisableAgent()
    {
        if (agent != null && agent.isActiveAndEnabled)
        {
            agent.enabled = false;
        }
    }
```

Ultimately this is the Patrolling Enemy which will be expanded with combat with the use of previously created inFOV method from blog post 1 of the enemy to activate the combat routine.

NOTE: We forgot to mention in the previous blog post, but all animations and character models were retrieved from mixamo.com

![alt text](InterruptEnemyInRoute.gif)
